<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#f0f2f5" />
  <meta name="color-scheme" content="light dark" />
  <title>Голосовой калькулятор</title>
  <link rel="icon" type="image/png" href="img/icon.png" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
  <script>
    (function initThemeEarly(){
      const THEME_COLORS={light:'#f0f2f5', dark:'#121212'};
      const themeMeta=document.querySelector('meta[name="theme-color"]');
      const applyThemeColor=theme=>{
        if(!themeMeta) return;
        const color=THEME_COLORS[theme]||THEME_COLORS.light;
        if(themeMeta.getAttribute('content')!==color){
          themeMeta.setAttribute('content', color);
        }
      };
      const KEY='app.theme';
      const FLAG='app.theme.explicit';
      const prefersDark=()=>window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const resolveModeTheme=mode=>mode==='dark' ? 'dark' : mode==='light' ? 'light' : (prefersDark() ? 'dark' : 'light');
      let mode='system';
      try{
        const saved=localStorage.getItem(KEY);
        const explicit=localStorage.getItem(FLAG)==='1';
        if(saved==='system' || !saved){
          mode='system';
        }else if(saved==='dark' || saved==='light'){
          if(explicit){
            mode=saved;
          }else if(saved==='dark'){
            mode='dark';
            localStorage.setItem(FLAG,'1');
          }else{
            mode='system';
            localStorage.removeItem(KEY);
          }
        }
      }catch(err){
        mode='system';
      }
      const theme=resolveModeTheme(mode);
      const docEl=document.documentElement;
      const surface=THEME_COLORS[theme]||THEME_COLORS.light;
      docEl.setAttribute('data-theme', theme);
      docEl.setAttribute('data-theme-mode', mode);
      docEl.style.backgroundColor=surface;
      docEl.style.colorScheme=theme==='dark'?'dark':'light';
      applyThemeColor(theme);
    })();
  </script>
  <style>
    :root{ --bg:#f0f2f5; --fg:#111; --muted:#666; --primary:#0a84ff; --card:#fff; --divider: rgba(0,0,0,.08); --input-bg:#fff;
      --safe-top: env(safe-area-inset-top); --safe-left: env(safe-area-inset-left); --safe-right: env(safe-area-inset-right); --safe-bottom: env(safe-area-inset-bottom); }
    [data-theme="dark"]{ --bg:#121212; --fg:#f5f5f7; --muted:#a0a0a0; --primary:#0a84ff; --card:#1e1e1e; --divider: rgba(255,255,255,0.1); --input-bg:#1b1f24; }
    *{ box-sizing:border-box; }
    html{ background:var(--bg); }
    html[data-theme="dark"]{ color-scheme:dark; }
    html[data-theme="light"]{ color-scheme:light; }
    html,body{ height:100vh; min-height:100vh; overflow:hidden; overscroll-behavior:none; touch-action:pan-x pan-y; }
    @supports (height: 100dvh){ html,body{ height:100dvh; min-height:100dvh; } }
    body{ margin:0; background:var(--bg); color:var(--fg); font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; -webkit-user-select:none; user-select:none; }
    input, textarea{ -webkit-user-select:text; user-select:text; }

    button, select { -webkit-tap-highlight-color: transparent; }
    .btn:focus, .navbtn:focus, .hamb:focus, select:focus { outline: none; }

    .screen{ position:relative; background:var(--card); height:100%; width:100%; overflow:hidden;
      padding: calc(var(--safe-top) + 16px) calc(var(--safe-right) + 16px) calc(var(--safe-bottom) + 20px) calc(var(--safe-left) + 16px);
      display:flex; align-items:stretch; justify-content:center; }
    .wrap{ width:min(640px, 96vw); height:100%; overflow:hidden; display:flex; flex-direction:column; gap:0; padding-top:0; }
    .view{ display:none; flex-direction:column; min-height:calc(100dvh - 64px - var(--safe-top) - var(--safe-bottom)); }
    .view.active{ display:flex; }

    .header{ text-align:center; padding: 0 16px; position:relative; }
    h1{ margin:0 0 8px; font-size:28px; font-weight:800; }
    #status{ color:var(--muted); min-height:24px; margin:0 0 12px; display:flex; align-items:center; justify-content:center; text-align:center; }

    /* Строка выражения — при переполнении уезжает влево, можно скроллить */
    #expr{ font-size:32px; font-weight:600; min-height:36px; margin:4px 0; white-space:nowrap; overflow-x:auto; overflow-y:hidden; text-align:right; -webkit-overflow-scrolling:touch; }
    #expr::-webkit-scrollbar{ display:none; }

    /* Большая строка результата — справа, плавно масштабируется, при переполнении «уезжает» влево */
    #full{ font-weight:800; font-size:64px; color:var(--primary); min-height:56px; margin:8px 0 18px; white-space:nowrap; overflow:hidden; line-height:1.1; text-align:right; will-change:font-size,transform; transition: font-size .18s ease, transform .18s ease; }
    #full[data-overflow="1"]{ -webkit-mask-image: linear-gradient(to right, rgba(0,0,0,0) 0, rgba(0,0,0,.12) 16px, #000 44px); mask-image: linear-gradient(to right, rgba(0,0,0,0) 0, rgba(0,0,0,.12) 16px, #000 44px); }

    .center{ display:flex; justify-content:center; align-items:center; width:100%; margin-top:6px; }
    .btn{ display:grid; place-items:center; border:0; cursor:pointer; user-select:none; touch-action:manipulation; background:var(--primary); color:#fff; box-shadow:0 8px 20px rgba(10,132,255,0.28); transition: transform .08s ease; }
    .btn:active{ transform: scale(.98); }
    .btn.circle{ width:160px; height:160px; border-radius:9999px; }
    .btn .title{ font-weight:800; font-size:16px; letter-spacing:.4px; }

    .history-block{ background:var(--card); border-radius:16px; padding:20px 20px 16px; width:min(360px,calc(100% - 32px)); margin:12px auto calc(36px + var(--safe-bottom)); display:flex; flex-direction:column; gap:16px; max-height:clamp(300px,48vh,440px); overflow:hidden; box-shadow:0 18px 40px rgba(0,0,0,0.28); }
    [data-theme="light"] .history-block{ box-shadow:0 22px 44px rgba(15,24,44,0.12); }
    .history-title{ margin:0; font-size:18px; font-weight:600; text-align:center; color:var(--fg); }
    .history-list{ list-style:none; margin:0; padding:4px 2px 4px 0; flex:1; min-height:0; overflow:auto; -webkit-overflow-scrolling:touch; touch-action:pan-y; }
    .history-list::-webkit-scrollbar{ display:none; }
    .history-list li{ padding:14px 0; border-bottom:1px solid var(--divider); display:flex; flex-direction:column; gap:4px; }
    .history-list li:last-child{ border-bottom:0; }
    .history-list .expr{ font-size:16px; font-weight:600; color:var(--fg); line-height:1.35; }
    .history-list .time{ font-size:14px; color:var(--muted); }
    [data-theme="light"] .history-title,
    [data-theme="light"] .history-list .expr,
    [data-theme="light"] .history-list .time{ color:#000; }
    [data-theme="light"] .history-list .time{ color:#5c5c5c; }
    .history-list li.empty{ color:var(--muted); font-size:14px; text-align:center; padding:24px 0; }
    .history-clear{ width:100%; background:#0a84ff; color:#fff; border:0; border-radius:10px; padding:14px 0; font-size:16px; font-weight:600; cursor:pointer; flex-shrink:0; box-shadow:0 10px 24px rgba(10,132,255,0.35); transition:transform .08s ease; }
    .history-clear:active{ transform:scale(.98); }

    .hamb{ position:fixed; top:calc(var(--safe-top) + 10px); left:calc(var(--safe-left) + 14px); width:48px; height:48px; border:0; border-radius:14px; background:var(--primary); color:#fff; font-size:24px; font-weight:800; display:grid; place-items:center; box-shadow:0 6px 16px rgba(10,132,255,.35); cursor:pointer; z-index:1100; }

    .drawer{ position: fixed; inset: 0 auto 0 0; width: min(300px, 90vw); background: var(--card); color: var(--fg); box-shadow: 0 10px 30px rgba(0,0,0,.2); transform: translateX(-100%); transition: none; will-change: transform; z-index: 1001; padding: 136px 18px 18px; overflow: auto; touch-action: none; }
    .scrim{ position: fixed; inset: 0; background: rgba(0,0,0,.6); opacity: 0; pointer-events: none; transition: none; will-change: opacity; z-index: 1000; touch-action: none; }
    #edge{ position:fixed; inset:0 auto 0 0; width:24px; z-index:1002; touch-action:none; background:transparent; }

    .navbtn{ appearance:none; display:block; width:100%; background:var(--input-bg); color:var(--fg); border:1px solid var(--divider); border-radius:18px; padding:16px 20px; margin:14px 0 0; text-align:left; font-weight:700; font-size:18px; box-shadow:0 6px 18px rgba(0,0,0,0.12); cursor:pointer; user-select:none; transition:background-color .15s ease, color .15s ease, box-shadow .15s ease, border-color .15s ease; }
    [data-theme="dark"] .navbtn{ box-shadow:0 10px 24px rgba(0,0,0,0.32); }
    .navbtn:active{ transform:translateY(1px); }
    .navbtn.active{ background:var(--primary); color:#fff; border-color:var(--primary); box-shadow:0 10px 24px rgba(10,132,255,0.32); }

    .about-body{ flex:1; display:flex; flex-direction:column; gap:16px; padding:0 16px; }
    .about-footer{ text-align:center; color:var(--muted); padding-top:6px; margin-bottom:calc(6px + var(--safe-bottom)); }
    .policy{ margin:0; max-height:60vh; overflow:auto; padding:12px; border:1px solid var(--divider); border-radius:12px; }
    .policy h2{ margin:0 0 8px; font-size:20px; font-weight:800; }
    .policy h3{ margin:12px 0 6px; font-size:16px; font-weight:800; }
    .policy p, .policy li { line-height: 1.45; }

    .field{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .label{ color:var(--muted); font-weight:600; }
    .theme-toggle{ display:inline-flex; background:var(--input-bg); border:1px solid var(--divider); padding:4px; border-radius:14px; box-shadow: inset 0 2px 6px rgba(0,0,0,.06); }
    .theme-toggle button{ appearance:none; border:0; background:transparent; padding:8px 12px; border-radius:10px; font-weight:700; color:var(--fg); cursor:pointer; transition:transform .08s ease; }
    .theme-toggle button.active{ background:var(--primary); color:#fff; box-shadow:0 6px 16px rgba(0,0,0,.25); }

    .dots span{ display:inline-block; width:8px; height:8px; background:var(--primary); border-radius:50%; margin:0 3px; animation:b 1.4s infinite ease-in-out both; }
    .dots span:nth-child(1){ animation-delay:-.32s } .dots span:nth-child(2){ animation-delay:-.16s }
    @keyframes b{0%,80%,100%{transform:scale(0)}40%{transform:scale(1)}}
  </style>
</head>
<body>
  <div id="edge"></div>
  <button id="btnMenu" class="hamb" aria-label="Меню">≡</button>

  <aside id="drawer" class="drawer" aria-hidden="true">
    <div style="font-weight:800; font-size:24px; margin-bottom:8px;">Меню</div>
    <button class="navbtn" data-view="calc">Калькулятор</button>
    <button class="navbtn" data-view="settings">Настройки</button>
    <button class="navbtn" data-view="about">О приложении</button>
  </aside>
  <div id="scrim" class="scrim"></div>

  <main class="screen">
    <div class="wrap">
      <section id="view-calc" class="view active">
        <div class="header">
          <h1>Голосовой калькулятор</h1>
          <p id="status"></p>
        </div>
        <div id="expr"></div>
        <div id="full"></div>
        <div class="center">
          <button id="btnListen" class="btn circle"><span class="title" id="btnTitle">НАЖМИ</span></button>
        </div>
        <div style="height:12px"></div>
        <div class="history-block">
          <h2 class="history-title">История вычислений</h2>
          <ul id="historyList" class="history-list"></ul>
          <button id="btnClearHistory" class="history-clear">Очистить</button>
        </div>
      </section>

      <section id="view-settings" class="view">
        <div class="header"><h1>Настройки</h1></div>
        <div class="about-body">
          <div class="field">
            <span class="label">Тема</span>
            <div id="themeToggle" class="theme-toggle" role="group" aria-label="Тема">
              <button type="button" data-value="light">Светлая</button>
              <button type="button" data-value="dark">Тёмная</button>
            </div>
          </div>
        </div>
      </section>

      <section id="view-about" class="view">
        <div class="header"><h1>О приложении</h1></div>
        <div class="about-body">
          <article class="policy">
            <h2>Политика конфиденциальности приложения «Голосовой калькулятор»</h2>
            <p><b>Дата последнего обновления:</b> 17 сентября 2025 г.</p>
            <h3>1. Общие положения</h3>
            <p>Мобильное приложение «Голосовой калькулятор» предназначено для голосовых вычислений. Используя Приложение, пользователь соглашается с условиями настоящей Политики.</p>
            <h3>2. Сбор и использование данных</h3>
            <ul>
              <li>Приложение не собирает и не хранит персональные данные пользователей.</li>
              <li>Голосовые команды обрабатываются локально на устройстве исключительно для выполнения вычислений и не передаются на сторонние серверы.</li>
            </ul>
            <h3>3. Разрешения и доступы</h3>
            <p>Приложение запрашивает доступ к микрофону для распознавания голосовых команд.</p>
            <h3>4. Передача третьим лицам</h3>
            <p>Персональные данные не продаются и не передаются третьим лицам. В приложении нет аналитики и рекламы.</p>
            <h3>5. Хранение и защита данных</h3>
            <p>История вычислений хранится локально и может быть удалена пользователем. Серверной части нет.</p>
            <h3>6. Права пользователя</h3>
            <ul>
              <li>отключить доступ к микрофону в системных настройках;</li>
              <li>очистить историю вычислений;</li>
              <li>удалить Приложение.</li>
            </ul>
            <h3>7. Дети</h3>
            <p>Приложение предназначено для широкой аудитории и не собирает данные детей.</p>
            <h3>8. Изменения политики</h3>
            <p>Дата последней редакции указывается в актуальной версии.</p>
            <h3>9. Контакты</h3>
            <p>Почта разработчика: <b>gameloft235@gmail.com</b>.</p>
          </article>
          <div class="about-footer">Версия <b>1.0.7</b></div>
        </div>
      </section>
    </div>
  </main>

  <script src="cordova.js"></script>
  <script>
  (function(){
    const $  = s=>document.querySelector(s);
    const $$ = s=>Array.from(document.querySelectorAll(s));

    /* ===== Блокируем масштабирование жестами ===== */
    (function preventPinchZoom(){
      const stop = e => e.preventDefault();
      document.addEventListener('gesturestart', stop, {passive:false});
      document.addEventListener('gesturechange', stop, {passive:false});
      document.addEventListener('gestureend', stop, {passive:false});
      document.addEventListener('touchstart', e=>{ if(e.touches.length>1) e.preventDefault(); }, {passive:false});
      document.addEventListener('touchmove', e=>{ if(e.touches.length>1) e.preventDefault(); }, {passive:false});
      window.addEventListener('wheel', e=>{ if(e.ctrlKey) e.preventDefault(); }, {passive:false});
    })();

    /* ===== Тема ===== */
    const THEME_KEY='app.theme';
    const THEME_EXPLICIT_KEY='app.theme.explicit';
    const themeToggle=$('#themeToggle');
    const themeMeta=document.querySelector('meta[name="theme-color"]');
    const docEl=document.documentElement;
    const bodyEl=document.body||document.documentElement;
    const SYSTEM_SURFACES={
      light:{ fallback:'#f0f2f5', statusStyle:'dark', navTheme:'light' },
      dark:{ fallback:'#121212', statusStyle:'light', navTheme:'dark' }
    };
    let deviceReady=false;

    const clamp255=v=>Math.max(0,Math.min(255,Math.round(v)));
    function normalizeHex(color){
      if(!color) return null;
      let c=String(color).trim();
      if(/^#[0-9a-f]{3}$/i.test(c)){
        c='#'+c.slice(1).split('').map(ch=>ch+ch).join('');
      }else if(/^#[0-9a-f]{8}$/i.test(c)){
        c='#'+c.slice(-6);
      }else if(!/^#[0-9a-f]{6}$/i.test(c)){
        const m=c.match(/^rgba?\(([^)]+)\)$/i);
        if(m){
          const parts=m[1].split(',').map(p=>parseFloat(p));
          if(parts.length>=3 && parts.slice(0,3).every(n=>Number.isFinite(n))){
            const [r,g,b]=parts;
            c='#'+[clamp255(r),clamp255(g),clamp255(b)].map(v=>v.toString(16).padStart(2,'0')).join('');
          }else{
            return null;
          }
        }else{
          return null;
        }
      }
      return c.toLowerCase();
    }

    function readCSSColor(varName, fallback){
      try{
        const styles=getComputedStyle(docEl);
        if(!styles) return fallback;
        const value=styles.getPropertyValue(varName);
        return value ? value.trim() || fallback : fallback;
      }catch(_){
        return fallback;
      }
    }

    function applyColorScheme(theme){
      const scheme=theme==='dark'?'dark':'light';
      docEl.style.colorScheme=scheme;
      bodyEl.style.colorScheme=scheme;
    }

    function applySystemSurfaces(theme){
      const preset=SYSTEM_SURFACES[theme]||SYSTEM_SURFACES.light;
      const bgColor=readCSSColor('--bg', preset.fallback);
      const metaColor=bgColor||preset.fallback;
      if(themeMeta && metaColor && themeMeta.getAttribute('content')!==metaColor){
        themeMeta.setAttribute('content', metaColor);
      }
      if(metaColor){
        docEl.style.backgroundColor=metaColor;
        bodyEl.style.backgroundColor=metaColor;
      }
      applyColorScheme(theme);
      if(!deviceReady) return;
      const statusHex=normalizeHex(readCSSColor('--bg', preset.fallback))||normalizeHex(metaColor)||normalizeHex(preset.fallback);
      try{
        if(window.StatusBar){
          if(statusHex && typeof StatusBar.backgroundColorByHexString==='function'){
            StatusBar.backgroundColorByHexString(statusHex);
          }
          if(preset.statusStyle==='light'){
            if(typeof StatusBar.styleLightContent==='function') StatusBar.styleLightContent();
          }else if(typeof StatusBar.styleDefault==='function'){
            StatusBar.styleDefault();
          }
        }
      }catch(_){ /* ignore */ }
      try{
        if(window.NavigationBar){
          const navHex=normalizeHex(readCSSColor('--bg', preset.fallback))||statusHex;
          const wantsLightBackground=preset.navTheme==='light';
          if(navHex){
            if(typeof NavigationBar.backgroundColorByHexString==='function'){
              if(NavigationBar.backgroundColorByHexString.length>=2){
                NavigationBar.backgroundColorByHexString(navHex, wantsLightBackground);
              }else{
                NavigationBar.backgroundColorByHexString(navHex);
              }
            }
            if(typeof NavigationBar.setNavigationBarColor==='function'){
              NavigationBar.setNavigationBarColor(navHex.replace('#',''), wantsLightBackground);
            }
          }
          if(typeof NavigationBar.setNavigationBarMode==='function'){
            NavigationBar.setNavigationBarMode(wantsLightBackground ? 'light' : 'dark');
          }
        }
      }catch(_){ /* ignore */ }
    }
    const mediaDark = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;
    let themeMode=document.documentElement.getAttribute('data-theme-mode')||'system';

    function resolveTheme(mode){
      if(mode==='dark' || mode==='light') return mode;
      return mediaDark && mediaDark.matches ? 'dark' : 'light';
    }
    function applyTheme(mode){
      themeMode=mode;
      const theme=resolveTheme(mode);
      docEl.setAttribute('data-theme-mode', mode);
      docEl.setAttribute('data-theme', theme);
      applySystemSurfaces(theme);
    }
    function setThemeUI(mode){
      if(!themeToggle) return;
      const effective = mode==='system' ? resolveTheme('system') : mode;
      themeToggle.querySelectorAll('button').forEach(btn=>{
        btn.classList.toggle('active', btn.dataset.value===effective);
      });
    }
    function getStoredTheme(){
      try{ return localStorage.getItem(THEME_KEY); }
      catch(_){ return null; }
    }
    function isThemeExplicit(){
      try{ return localStorage.getItem(THEME_EXPLICIT_KEY)==='1'; }
      catch(_){ return false; }
    }
    function saveTheme(mode){
      try{
        if(mode==='system'){
          localStorage.setItem(THEME_KEY,'system');
          localStorage.removeItem(THEME_EXPLICIT_KEY);
        }else{
          localStorage.setItem(THEME_KEY,mode);
          localStorage.setItem(THEME_EXPLICIT_KEY,'1');
        }
      }catch(_){ /* ignore */ }
    }
    function clearThemePreference(){
      try{
        localStorage.removeItem(THEME_KEY);
        localStorage.removeItem(THEME_EXPLICIT_KEY);
      }catch(_){ /* ignore */ }
    }
    function determineInitialMode(){
      const saved=getStoredTheme();
      const explicit=isThemeExplicit();
      if(saved==='system' || !saved) return 'system';
      if(saved==='dark' || saved==='light'){
        if(explicit){
          return saved;
        }
        if(saved==='dark'){
          saveTheme('dark');
          return 'dark';
        }
        clearThemePreference();
        return 'system';
      }
      return 'system';
    }
    (function initTheme(){
      themeMode = document.documentElement.getAttribute('data-theme-mode') || determineInitialMode();
      applyTheme(themeMode);
      setThemeUI(themeMode);
      if(mediaDark){
        const handleSystemChange=e=>{
          if(themeMode==='system'){
            applyTheme('system');
            setThemeUI('system');
          }
        };
        if(mediaDark.addEventListener) mediaDark.addEventListener('change', handleSystemChange);
        else if(mediaDark.addListener) mediaDark.addListener(handleSystemChange);
      }
      if(themeToggle){
        themeToggle.addEventListener('click', e=>{
          const btn=e.target.closest('button[data-value]');
          if(!btn) return;
          const mode=btn.dataset.value;
          if(mode!=='light' && mode!=='dark') return;
          if(themeMode===mode) return;
          saveTheme(mode);
          applyTheme(mode);
          setThemeUI(mode);
        });
      }
    })();

    document.addEventListener('deviceready', ()=>{
      deviceReady=true;
      try{
        if(window.StatusBar && typeof StatusBar.overlaysWebView==='function'){
          StatusBar.overlaysWebView(false);
        }
      }catch(_){ /* ignore */ }
      applySystemSurfaces(resolveTheme(themeMode));
    });

    /* ===== Шторка (жесты) ===== */
    const drawer=$('#drawer'), scrim=$('#scrim'), btnMenu=$('#btnMenu'), edge=$('#edge');
    let isOpen=false, dragging=false, modeDrag='', startX=0, lastX=0, lastT=0, vX=0, w=0, pos=-300, moved=false;
    const measure=()=>{ w=drawer.getBoundingClientRect().width||280; };
    const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
    const setPos=px=>{ pos=clamp(px,-w,0); drawer.style.transform=`translateX(${pos}px)`; const k=1+pos/w; scrim.style.opacity=(0.6*k).toFixed(3); scrim.style.pointerEvents=k>0.02?'auto':'none'; };
    const stopTr=()=>{ drawer.style.transition='none'; scrim.style.transition='none'; };
    const animateTo=px=>{ drawer.style.transition='transform 280ms cubic-bezier(.2,.8,.2,1)'; scrim.style.transition='opacity 280ms cubic-bezier(.2,.8,.2,1)'; requestAnimationFrame(()=>setPos(px)); setTimeout(stopTr,300); };
    const openDrawer = ()=>{ measure(); isOpen=true; edge.style.pointerEvents='none';  animateTo(0); };
    const closeDrawer= ()=>{ measure(); isOpen=false; edge.style.pointerEvents='auto'; animateTo(-w); };
    const toggleDrawer=()=> isOpen?closeDrawer():openDrawer();
    btnMenu.addEventListener('click',e=>{ e.preventDefault(); toggleDrawer(); });
    scrim.addEventListener('click', closeDrawer);
    let swallowTimer=0;
    let swallowCleanup=null;
    function swallowClick(allowSelector){
      if(swallowCleanup){ swallowCleanup(); }
      const handler=e=>{
        if(allowSelector && e.target.closest(allowSelector)){
          cleanup();
          return;
        }
        e.stopPropagation();
        e.preventDefault();
        cleanup();
      };
      const cleanup=()=>{
        window.removeEventListener('click',handler,true);
        if(swallowTimer){ clearTimeout(swallowTimer); swallowTimer=0; }
        swallowCleanup=null;
      };
      swallowCleanup=cleanup;
      window.addEventListener('click',handler,true);
      swallowTimer=setTimeout(cleanup,300);
    }
    function beginOpen(x){ measure(); dragging=true; modeDrag='open';  startX=lastX=x; lastT=performance.now(); vX=0; moved=false; stopTr(); setPos(-w); }
    function beginClose(x){ measure(); dragging=true; modeDrag='close'; startX=lastX=x; lastT=performance.now(); vX=0; moved=false; stopTr(); setPos(0); }
    function moveTo(x){ const dx=x-startX; if(!moved && Math.abs(dx)>6) moved=true; if(modeDrag==='open') setPos(-w+dx); else setPos(0+dx); const now=performance.now(), dt=now-lastT; if(dt>0){ vX=(x-lastX)/dt; lastX=x; lastT=now; } }
    function endDrag(e){
      if(!dragging) return;
      const allowSelector = modeDrag==='open' ? '.navbtn' : null;
      if(moved) swallowClick(allowSelector);
      e.currentTarget.releasePointerCapture?.(e.pointerId);
      dragging=false;
      const opened=1+pos/w;
      const TH=0.35, VE=0.35;
      if(modeDrag==='open'){
        (opened>TH || vX>VE)?openDrawer():closeDrawer();
      } else {
        (opened<(1-TH) || vX<-VE)?closeDrawer():openDrawer();
      }
    }
    edge.addEventListener('pointerdown',e=>{ edge.setPointerCapture(e.pointerId); beginOpen(e.clientX); });
    edge.addEventListener('pointermove', e=>{ if(dragging&&modeDrag==='open')  moveTo(e.clientX); });
    edge.addEventListener('pointerup',   endDrag); edge.addEventListener('pointercancel',endDrag);
    drawer.addEventListener('pointerdown',e=>{
      if(e.target.closest('.navbtn')) return; // allow immediate taps on menu buttons
      drawer.setPointerCapture?.(e.pointerId);
      beginClose(e.clientX);
    });
    drawer.addEventListener('pointermove', e=>{ if(dragging&&modeDrag==='close') moveTo(e.clientX); });
    drawer.addEventListener('pointerup',   endDrag); drawer.addEventListener('pointercancel',endDrag);
    scrim.addEventListener('pointerdown', e=>{ scrim.setPointerCapture?.(e.pointerId); beginClose(e.clientX); });
    scrim.addEventListener('pointermove', e=>{ if(dragging&&modeDrag==='close') moveTo(e.clientX); });
    scrim.addEventListener('pointerup',   endDrag); scrim.addEventListener('pointercancel',endDrag);

    /* ===== Навигация ===== */
    const views={calc:'#view-calc',settings:'#view-settings',about:'#view-about'};
    const setActiveNav=view=>{
      $$('.navbtn').forEach(btn=>btn.classList.toggle('active', btn.dataset.view===view));
    };
    const showView=k=>{
      Object.values(views).forEach(sel=>document.querySelector(sel).classList.remove('active'));
      (document.querySelector(views[k])||document.querySelector(views.calc)).classList.add('active');
      setActiveNav(k in views ? k : 'calc');
    };
    const activateNav=view=>{ showView(view); closeDrawer(); };
    $$('.navbtn').forEach(btn=>{
      let pointerActive=false;
      let suppressClick=false;
      const view=btn.dataset.view;
      btn.addEventListener('pointerdown',e=>{
        if(e.pointerType==='mouse' && e.button!==0) return;
        pointerActive=true;
        if(typeof swallowCleanup==='function') swallowCleanup();
      });
      const resetPointer=()=>{ pointerActive=false; };
      btn.addEventListener('pointerleave', resetPointer);
      btn.addEventListener('pointercancel', resetPointer);
      btn.addEventListener('pointerup',e=>{
        if(!pointerActive) return;
        if(e.pointerType==='mouse' && e.button!==0) return;
        pointerActive=false;
        suppressClick=true;
        e.preventDefault();
        activateNav(view);
        setTimeout(()=>{ suppressClick=false; },0);
      });
      btn.addEventListener('click',e=>{
        if(suppressClick) return;
        activateNav(view);
      });
    });
    setActiveNav('calc');

    /* ===== История ===== */
    const HIST_KEY='calc.history', historyList=$('#historyList');
    const loadHistory=()=>{try{return JSON.parse(localStorage.getItem(HIST_KEY)||'[]')}catch(_){return[]}};
    const saveHistory=a=>localStorage.setItem(HIST_KEY,JSON.stringify(a));
    const pushHistory=(expr,res)=>{ const a=loadHistory(); a.unshift({t:Date.now(),expr,res}); if(a.length>200)a.length=200; saveHistory(a); renderHistory(); };
    const formatTime=ts=>new Date(ts).toLocaleString();
    function renderHistory(){
      const a=loadHistory();
      historyList.innerHTML = a.length
        ? a.map(i=>`<li><div class="expr">${i.expr} = ${i.res}</div><div class="time">${formatTime(i.t)}</div></li>`).join('')
        : '<li class="empty">Пока пусто</li>';
    }
    $('#btnClearHistory').addEventListener('click',()=>{ saveHistory([]); renderHistory(); });

    /* ===== Нормализация/словари ===== */
    function normalizeNumeralTypos(s){
      return String(s)
        .toLowerCase().replace(/ё/g,'е')
        .replace(/[\u00A0\u202F]/g,' ')
        // масштабы и разговорные
        .replace(/\bт[ьи]сяч[а-я]*\b/g,'тысяч')
        .replace(/\bтысяц[а-я]*\b/g,'тысяч')
        .replace(/\bтыща\b/g,'тысяч')
        .replace(/\bтыщ\b/g,'тысяч')
        .replace(/\bтыс\.?\b/g,'тысяч')
        .replace(/\bмлн\.?\b/g,'миллион')
        .replace(/\bмлрд\.?\b/g,'миллиард')
        // порядковые -> количественные
        .replace(/\bперв(ой|ый|ая|ое|ую|ого|ому|ыми|ых|ым)\b/g,'один')
        .replace(/\bвтор(ой|ый|ая|ое|ую|ого|ому|ыми|ых|ым)\b/g,'два')
        .replace(/\bтрет(?:ий|ья|ье|ью|ьей|ьим|ьих|ей)\b/g,'три')
        .replace(/\bтреть(?:я|ей|ю|е)?\b/g,'три')
        .replace(/\bчетверт(?:ой|ый|ая|ое|ую|ого|ому|ыми|ых|ым)\b/g,'четыре')
        .replace(/\bпят(ой|ый|ая|ое|ую|ого|ому|ыми|ых|ым)\b/g,'пять')
        .replace(/\bшест(ой|ый|ая|ое|ую|ого|ому|ыми|ых|ым)\b/g,'шесть')
        .replace(/\bседьм(ой|ый|ая|ое|ую|ого|ому|ыми|ых|ым)\b/g,'семь')
        .replace(/\bвосьм(ой|ый|ая|ое|ую|ого|ому|ыми|ых|ым)\b/g,'восемь')
        .replace(/\bдевят(ой|ый|ая|ое|ую|ого|ому|ыми|ых|ым)\b/g,'девять')
        .replace(/\bдесят(ой|ый|ая|ое|ую|ого|ому|ыми|ых|ым)\b/g,'десять')
        // родительные падежи после "из" или при указании долей
        .replace(/(^|\s)одн(?:ой|ого|ому|ым|ых)(?=\s|$)/g,'$1один')
        .replace(/(^|\s)двух(?=\s|$)/g,'$1два')
        .replace(/(^|\s)тр(?:ех|ёх)(?=\s|$)/g,'$1три')
        .replace(/(^|\s)четыр(?:ех|ёх)(?=\s|$)/g,'$1четыре')
        .replace(/(^|\s)пяти(?=\s|$)/g,'$1пять')
        .replace(/(^|\s)шести(?=\s|$)/g,'$1шесть')
        .replace(/(^|\s)семи(?=\s|$)/g,'$1семь')
        .replace(/(^|\s)восьми(?=\s|$)/g,'$1восемь')
        .replace(/(^|\s)девяти(?=\s|$)/g,'$1девять')
        .replace(/(^|\s)десяти(?=\s|$)/g,'$1десять')
        // «миллион/миллиард», но НЕ «миллионных/миллиардных»
        .replace(/\bмиль?и?он(?!н[а-я])([а-я]*)\b/g,'миллион$1')
        .replace(/\bмили?ард(?!н[а-я])([а-я]*)\b/g,'миллиард$1')
        .replace(/\bмильон([а-я]*)\b/g,'миллион$1')
        .replace(/\bмильярд([а-я]*)\b/g,'миллиард$1')
        // десятки/сотни опечатки
        .replace(/\bтридать\b/g,'тридцать')
        .replace(/\bшестьдесять\b/g,'шестьдесят')
        .replace(/\bсемьдесять\b/g,'семьдесят')
        .replace(/\bвосемьдесять\b/g,'восемьдесят')
        .replace(/\bшесдесят\b/g,'шестьдесят')
        .replace(/\bсемдесят\b/g,'семьдесят')
        .replace(/\bвосемдесят\b/g,'восемьдесят')
        .replace(/\bдевяноста\b/g,'девяносто')
        // сотни
        .replace(/\bдвесте\b/g,'двести')
        .replace(/\bдвисти\b/g,'двести')
        .replace(/\bтристо\b/g,'триста')
        .replace(/\bчетыр?иста\b/g,'четыреста')
        .replace(/\bпятсот\b/g,'пятьсот')
        .replace(/\bпяцот\b/g,'пятьсот')
        .replace(/\bшессот\b/g,'шестьсот')
        .replace(/\bшесот\b/g,'шестьсот')
        .replace(/\bсемсот\b/g,'семьсот')
        .replace(/\bвосемсот\b/g,'восемьсот')
        .replace(/\bдевя[сз]от\b/g,'девятьсот')
        // «минус17» → «минус 17»
        .replace(/\bминус(?=\d)/g,'минус ');
    }
    function foldCompoundHundreds(s){
      return s
        .replace(/\bод(ин|на)\s+сот(ня|ни|ен)?\b/g,'сто')
        .replace(/\bдв(а|е)\s+сот(ня|ни|ен)?\b/g,'двести')
        .replace(/\bтри\s+сот(ня|ни|ен)?\b/g,'триста')
        .replace(/\bчетыре\s+сот(ня|ни|ен)?\b/g,'четыреста')
        .replace(/\bпять\s+сот(ня|ни|ен)?\b/g,'пятьсот')
        .replace(/\bшесть\s+сот(ня|ни|ен)?\b/g,'шестьсот')
        .replace(/\bсемь\s+сот(ня|ни|ен)?\b/g,'семьсот')
        .replace(/\bвосемь\s+сот(ня|ни|ен)?\b/g,'восемьсот')
        .replace(/\bдевять\s+сот(ня|ни|ен)?\b/g,'девятьсот');
    }

    const UNITS={ 'ноль':0,'один':1,'одна':1,'два':2,'две':2,'три':3,'четыре':4,'пять':5,'шесть':6,'семь':7,'восемь':8,'девять':9,
      'десять':10,'одиннадцать':11,'двенадцать':12,'тринадцать':13,'четырнадцать':14,'пятнадцать':15,'шестнадцать':16,'семнадцать':17,'восемнадцать':18,'девятнадцать':19 };
    const TENS={ 'двадцать':20,'тридцать':30,'сорок':40,'пятьдесят':50,'шестьдесят':60,'семьдесят':70,'восемьдесят':80,'девяносто':90 };
    const HUNS={ 'сто':100,'двести':200,'триста':300,'четыреста':400,'пятьсот':500,'шестьсот':600,'семьсот':700,'восемьсот':800,'девятьсот':900 };
    const SCALE={
      'тысяча':1_000,'тысячи':1_000,'тысяч':1_000,'тыс':1_000,'тыс.':1_000,
      'миллион':1_000_000,'миллиона':1_000_000,'миллионов':1_000_000,'млн':1_000_000,'млн.':1_000_000,
      'миллиард':1_000_000_000,'миллиарда':1_000_000_000,'миллиардов':1_000_000_000,'млрд':1_000_000_000,'млрд.':1_000_000_000
    };
    const DIGITWORD={'ноль':'0','один':'1','одна':'1','два':'2','две':'2','три':'3','четыре':'4','пять':'5','шесть':'6','семь':'7','восемь':'8','девять':'9'};

    function tokenizeRu(s){
      s = String(s).replace(/[.,!?;:(){}\[\]]/g,' ').trim();
      const out = s.match(/[A-Za-zА-Яа-яЁё]+|\d+/g) || [];
      return out;
    }

    // Свёртка русских числительных в число с поддержкой масштабов
    // Работает для: "один миллион пятьсот девяносто тысяч шестьсот семьдесят восемь" -> 1590678
    // и "2 млн 3 тыс. 45" -> 2003045, а также с «полтора/полторы».
    function wordsToNumber(str){
      const norm = foldCompoundHundreds(normalizeNumeralTypos(str));
      const tokens = tokenizeRu(norm).map(t => t.toLowerCase());

      let total = 0;   // сумма по завершённым масштабным группам
      let group = 0;   // текущая незавершённая группа <= 999 (может быть дробной из-за «полтора»)
      let seen = false;

      const pushScale = (scale) => {
        const base = group === 0 ? 1 : group;
        total += base * scale;
        group = 0;
      };

      for (let w of tokens){
        if (w === 'и') { continue; }

        if (/^\d+$/.test(w)) { group += parseInt(w,10); seen = true; continue; }

        if (w === 'полтора' || w === 'полторы') { group += 1.5; seen = true; continue; }

        if (HUNS[w]  !== undefined) { group += HUNS[w];  seen = true; continue; }
        if (TENS[w]  !== undefined) { group += TENS[w];  seen = true; continue; }
        if (UNITS[w] !== undefined) { group += UNITS[w]; seen = true; continue; }

        if (SCALE[w] !== undefined) { pushScale(SCALE[w]); seen = true; continue; }

        if (w.startsWith('тысяч')) { pushScale(1_000); seen = true; continue; }
        if (w.startsWith('миллион')) { pushScale(1_000_000); seen = true; continue; }
        if (w.startsWith('миллиард')) { pushScale(1_000_000_000); seen = true; continue; }
      }

      if (!seen) return NaN;
      return total + group;
    }

    function extractNumberRu(input){
      let s = String(input||'').trim()
        .replace(/ё/g,'е')
        .replace(/[\u00A0\u202F]/g,' ')
        .replace(/(\d)([a-zа-яё]+)/gi,'$1 $2');

      s = foldCompoundHundreds(normalizeNumeralTypos(s));

      // «258 , 3»/«258 . 3» (только между цифрами) → десятичная точка
      s = s.replace(/(\d)\s*[.,]\s*(\d)/g,'$1.$2');

      // унарный минус словами/знаком
      const mneg = s.match(/^\s*(?:-+|минус)\s*(.+)$/i);
      if (mneg) {
        const rest = mneg[1];
        const val = parseFloat(extractNumberRu(rest)||'0')||0;
        return String(-val);
      }

      // готовые числовые форматы с разделителями тысяч
      if (/^[-+]?\d{1,3}(?:[ \u00A0\u202F]?\d{3})+(?:[.,]\d+)?$/.test(s))
        return String(parseFloat(s.replace(/[ \u00A0\u202F]/g,'').replace(',', '.')));
      if (/^[-+]?\d{1,3}(?:\.\d{3})+(?:,\d+)?$/.test(s))
        return String(parseFloat(s.replace(/\./g,'').replace(',', '.')));
      if (/^[-+]?\d{1,3}(?:['’]\d{3})+(?:[.,]\d+)?$/.test(s))
        return String(parseFloat(s.replace(/['’]/g,'').replace(',', '.')));

      let m;

      // «A . B» / «A , B» (A/B — слова или цифры)
      if (m = s.match(/^(.+?)\s*[\.,]\s*(.+)$/)) {
        const ipStr = m[1].trim();
        const ip = (/^\d+$/.test(ipStr)) ? parseInt(ipStr,10) : wordsToNumber(ipStr);
        const rest = m[2].trim();
        const allDigits = rest.split(/\s+/).every(t=> DIGITWORD[t]!==undefined || /^\d+$/.test(t));
        const decStr = allDigits
          ? rest.split(/\s+/).map(t=> /^\d+$/.test(t)? t : DIGITWORD[t]).join('')
          : String((/^\d+$/.test(rest)? parseInt(rest,10) : wordsToNumber(rest)));
        return String(parseFloat(ip + '.' + decStr));
      }

      // полтора/пол… + масштаб + хвост
      if (m = s.match(/^\s*(полтора|полторы)\s+(тысяч[а-я]*|миллион[а-я]*|миллиард[а-я]*|млн|млрд)\b(.*)$/i)){
        const sw = m[2].toLowerCase();
        const mult = sw.startsWith('тыс')?1_000:(sw.startsWith('млрд')||sw.startsWith('миллиард')?1_000_000_000:1_000_000);
        const head = 1.5 * mult; const tail = m[3].trim();
        if (tail){ const tv = parseFloat(extractNumberRu(tail)||'0')||0; return String(head + tv); }
        return String(head);
      }
      if (m = s.match(/^\s*пол(тысячи|миллиона|миллиарда|млн|млрд)\b(.*)$/i)){
        const sw = m[1].toLowerCase();
        const k = sw.startsWith('тыс')?1_000:(sw.startsWith('млрд')||sw.startsWith('миллиард')?1_000_000_000:1_000_000);
        const head = 0.5 * k; const tail = (m[2]||'').trim();
        if (tail){ const tv = parseFloat(extractNumberRu(tail)||'0')||0; return String(head + tv); }
        return String(head);
      }

      // «X с половиной», «X 1/2», «X½»
      if (m = s.match(/^(.+?)\s+(?:с|и)?\s*половин(?:ой|а|у|е|ы)?$/i)){
        const baseStr = m[1].trim();
        const base = (/^\d+$/.test(baseStr)) ? parseInt(baseStr,10) : wordsToNumber(baseStr);
        return String(base + 0.5);
      }
      if (m = s.match(/^(.+?)\s*(?:1\/2|½)$/)){
        const baseStr = m[1].trim();
        const base = (/^\d+$/.test(baseStr)) ? parseInt(baseStr,10) : wordsToNumber(baseStr);
        return String(base + 0.5);
      }

      // «X целых|точка|запятая Y …»
      if (m = s.match(/^(.+?)\s+(целых?|целая|целое|запятая|точка)\s+(.+)$/i)){
        const ipStr = m[1].trim();
        const ip = (/^\d+$/.test(ipStr)) ? parseInt(ipStr,10) : wordsToNumber(ipStr);
        const rest = normalizeNumeralTypos(m[3].trim());
        const mu = rest.match(/^(.*?)\s+(десятых?|десятая|десятую|сотых?|сотая|сотую|тысячных?|тысячная|тысячную|десятитысячных?|десятитысячная|десятитысячную|стотысячных?|стотысячная|стотысячную|миллионных?|миллионная|миллионную|миллиардных?|миллиардная|миллиардную)$/i);
        if (mu){
          const nStr = mu[1].trim();
          const n = (/^\d+$/.test(nStr)) ? parseInt(nStr,10) : wordsToNumber(nStr);
          const unit = mu[2].toLowerCase();
          let pad = 1;
          if (/^десятитысяч/.test(unit)) pad = 4;
          else if (/^стотысяч/.test(unit)) pad = 5;
          else if (/^миллион/.test(unit)) pad = 6;
          else if (/^миллиард/.test(unit)) pad = 9;
          else if (/^сот/.test(unit)) pad = 2;
          else if (/^тысяч/.test(unit)) pad = 3;
          return ip + '.' + String(n).padStart(pad,'0');
        }
        const allDigits = rest.split(/\s+/).every(t=> DIGITWORD[t]!==undefined || /^\d+$/.test(t));
        const decStr = allDigits
          ? rest.split(/\s+/).map(t=> /^\d+$/.test(t)? t : DIGITWORD[t]).join('')
          : String((/^\d+$/.test(rest)? parseInt(rest,10) : wordsToNumber(rest)));
        return ip + '.' + decStr;
      }

      // «N тысяч/миллион/миллиард» без хвоста
      if (m = s.match(/^\s*(.+?)\s+(тысяч[а-я]*|миллион[а-я]*|миллиард[а-я]*|млн|млрд)\s*$/i)) {
        const qStr = m[1].trim();
        const sw = m[2].toLowerCase();
        const mult = sw.startsWith('тыс')?1_000:(sw.startsWith('млрд')||sw.startsWith('миллиард')?1_000_000_000:1_000_000);
        const q = (/^\d+$/.test(qStr)) ? parseInt(qStr,10) : wordsToNumber(qStr || 'один');
        return String((q||1) * mult);
      }

      // простое число цифрами
      if (/^[-+]?\d+(?:[.,]\d+)?$/.test(s))
        return String(parseFloat(s.replace(',', '.')));

      // слова → число с масштабами
      const num = wordsToNumber(s);
      return isNaN(num) ? s : String(num);
    }

    /* ===== Форматирование вывода ===== */
    function isDigits(str){ for(let i=0;i<str.length;i++){ const c=str.charCodeAt(i); if(c<48||c>57) return false; } return str.length>0; }
    function formatNumberSpaces(value){
      const s = String(value);
      let rest = s; let sign='';
      if(rest[0]==='-'||rest[0]==='+'){ sign = (rest[0]==='-')?'-':''; rest = rest.slice(1); }
      const parts = rest.split('.');
      const intPart = parts[0]||''; const decPart = parts[1]||'';
      if(!isDigits(intPart) || (decPart && !isDigits(decPart))) return s;
      let grouped='';
      for(let i=0;i<intPart.length;i++){
        if(i>0 && (intPart.length - i) % 3 === 0) grouped += ' ';
        grouped += intPart[i];
      }
      return sign + grouped + (decPart?('.'+decPart):'');
    }

    /* ===== Разбор выражения ===== */
// "X на Y" → "X * Y" (когда ASR съел слово «умножь»)
function fixNaMultiplication(str){
  // цифры: "12 на 3" → "12 * 3"
  str = str.replace(/(\d+(?:[.,]\d+)?)\s+на\s+(\d+(?:[.,]\d+)?)/gi, '$1 * $2');
  // слова (включая десятки/сотни/масштабы): "пять на три" → "пять * три"
  const w = '(?:ноль|один|одна|два|две|три|четыре|пять|шесть|семь|восемь|девять|десять|одиннадцать|двенадцать|тринадцать|четырнадцать|пятнадцать|шестнадцать|семнадцать|восемнадцать|девятнадцать|двадцать|тридцать|сорок|пятьдесят|шестьдесят|семьдесят|восемьдесят|девяносто|сто|двести|триста|четыреста|пятьсот|шестьсот|семьсот|восемьсот|девятьсот|тысяч[а-я]*|миллион[а-я]*|миллиард[а-я]*)';
  const re = new RegExp('(^|\s)('+w+')\s+на\s+('+w+')(?=\s|$)','gi');
  return str.replace(re, (m, lead,a,b)=> lead+a+' * '+b);
}

// "X дели Y" → "X / Y" (когда распознавание пропустило слово «на»)
function fixNaDivision(str){
  // цифры: "12 дели 3" → "12 / 3"
  str = str.replace(/(\d+(?:[.,]\d+)?)\s+(?:дели|раздели|подели|поделить)\s+(\d+(?:[.,]\d+)?)/gi,'$1 / $2');
  // слова и масштабы: "шесть дели три" → "шесть / три"
  const w='(?:ноль|один|одна|два|две|три|четыре|пять|шесть|семь|восемь|девять|десять|одиннадцать|двенадцать|тринадцать|четырнадцать|пятнадцать|шестнадцать|семнадцать|восемнадцать|девятнадцать|двадцать|тридцать|сорок|пятьдесят|шестьдесят|семьдесят|восемьдесят|девяносто|сто|двести|триста|четыреста|пятьсот|шестьсот|семьсот|восемьсот|девятьсот|тысяч[а-я]*|тыс\.?|миллион[а-я]*|млн\.?|миллиард[а-я]*|млрд\.?)';
  const re=new RegExp('(^|\\s)('+w+')\s+(?:дели|раздели|подели|поделить)\s+('+w+')(?=\\s|$)','gi');
  return str.replace(re,(m,lead,a,b)=>lead+a+' / '+b);
}

// После "*" если идут «голые» числа или списки через запятую/«и/на», вставляем "*" между ними.
// "* 5 3" → "* 5 * 3", "* пять, три" → "* пять * три".
// Не ломает составные "двадцать три": десятки/сотни/масштабы не считаются «атомарными».
function insertStarsAfterStar(str){
  const toks = String(str).split(/\s+/).filter(Boolean);
  const out = [];
  let afterStar = false;
  let prevAtomic = false; // предыдущий токен после "*" был атомарным (цифра или слово-единица)
  const isDigitTok = t => /^\d+(?:[.,]\d+)?$/.test(t);
  const isUnitTok = t => UNITS[t.toLowerCase()] !== undefined; // один.. девять, десять.. девятнадцать
  const isTensOrHundOrScale = t => {
    t = t.toLowerCase();
    return TENS[t] !== undefined || HUNS[t] !== undefined ||
           /^тысяч/.test(t) || /^миллион/.test(t) || /^миллиард/.test(t) ||
           t==='млн' || t==='млрд';
  };
  for (let i=0; i<toks.length; i++){
    let tok = toks[i];
    let clean = tok.replace(/[,;]+$/, '');
    const hadSep = clean.length !== tok.length; // был разделитель в конце
    tok = clean;
    const low = tok.toLowerCase();
    if (tok==='*'){
      out.push(tok);
      afterStar=true;
      prevAtomic=false;
      continue;
    }
    if (['+','-','/','(',')'].includes(tok)){
      out.push(tok);
      afterStar=false;
      prevAtomic=false;
      continue;
    }
    if (!afterStar){
      if (tok) out.push(tok);
      continue;
    }
    // внутри хвоста после "*": разделители/союзы
    if (low==='и' || low==='на'){
      out.push('*');
      prevAtomic=false;
      if (hadSep){ out.push('*'); }
      continue;
    }
    if (!tok){
      out.push('*');
      prevAtomic=false;
      continue;
    }
    const atomic = isDigitTok(tok) || isUnitTok(tok);
    const tensHundScale = isTensOrHundOrScale(tok);
    if (prevAtomic && atomic){
      out.push('*');
    }
    out.push(tok);
    prevAtomic = atomic && !tensHundScale;
    if (hadSep){
      if (toks[i+1] !== '*') out.push('*');
      prevAtomic=false;
    }
  }
  return out.join(' ');
}

// Regex-добивка: последовательно идущие цифры или слова-единицы после "*" → перемножаем.
function insertStarsBetweenBareNumbers(str){
  // цифры: "* 5 3" → "* 5 * 3"
  str = str.replace(/(\*)\s*((?:\d+(?:[.,]\d+)?\s+){1,}\d+(?:[.,]\d+)?)/g,
                     (_, star, seq) => star + ' ' + seq.trim().replace(/\s+/g, ' * '));
  // слова-единицы: "* пять три" → "* пять * три"
  const unit = '(?:ноль|один|одна|два|две|три|четыре|пять|шесть|семь|восемь|девять)';
  const reg = new RegExp('(\\*)\\s*((?:' + unit + '\\s+){1,}' + unit + ')','gi');
  str = str.replace(reg, (_, star, seq) => star + ' ' + seq.trim().replace(/\s+/g, ' * '));
  return str;
}

// Схлопываем повторяющиеся "*" (во избежание "* *" → "**" → возведение в степень)
function collapseRepeatedStars(str){
  return str.replace(/\*(?:\s*\*)+/g,'*');
}

// Если оператор пропал, а осталось только "1380 4" → добавим "+" → "1380 + 4"
function insertPlusBetweenNumbers(str){
  return str.replace(/(\d+(?:\s\d{3})*)\s(\d{1,2})(?=($|[^0-9]))/g,(m,a,b)=>{
    const first = parseInt(a.replace(/\s/g,''),10);
    return first>=100 ? `${a} + ${b}` : m;
  });
}

// "* пять и три" / "* 5, 3" / "* пять, три" → "* пять * три"
function expandMultiplicativeList(str){
  return str.replace(/(\*)(\s*)([^+\-*/]+)/g, (m, star, sp, tail)=>{
    const parts = tail
      .replace(/[,;]+/g, ' и ')
      .split(/\s+и\s+/)
      .map(s=>s.trim())
      .filter(Boolean);
    if(parts.length<=1) return m;
    const isNumWord = t=>{
      t=t.toLowerCase();
      return /^\d+(?:[.,]\d+)?$/.test(t) ||
             UNITS[t]!==undefined || TENS[t]!==undefined || HUNS[t]!==undefined ||
             /^тысяч/.test(t) || /^миллион/.test(t) || /^миллиард/.test(t) ||
             t==='млн' || t==='млрд';
    };
    const ok = parts.every(p=>p.split(/\s+/).every(isNumWord));
    if(!ok) return m;
    return star + ' ' + parts.join(' * ');
  });
}

// После "%" или слова "процент" если сразу идёт число/числительное,
// вставляем "*", чтобы не получилось сложение "10% 5" → "10% * 5".
function insertStarAfterPercent(str){
  str = str.replace(/(процент(?:а|ов)?|%)\s+на\s+/gi, '$1 * ');
  const unit = '(?:ноль|один|одна|два|две|три|четыре|пять|шесть|семь|восемь|девять|десять|одиннадцать|двенадцать|тринадцать|четырнадцать|пятнадцать|шестнадцать|семнадцать|восемнадцать|девятнадцать|двадцать|тридцать|сорок|пятьдесят|шестьдесят|семьдесят|восемьдесят|девяносто|сто|двести|триста|четыреста|пятьсот|шестьсот|семьсот|восемьсот|девятьсот|тысяч[а-я]*|миллион[а-я]*|миллиард[а-я]*)';
  const reg = new RegExp('(процент(?:а|ов)?|%)\\s+(?=(?:\\d+(?:[.,]\\d+)?|'+unit+')(?:\\s|$))','gi');
  return str.replace(reg,'$1 * ');
}
function stripFractionPhrases(str){
  const NUM = '(?:\\d+(?:[.,]\\d+)?|[а-яё]+(?:\\s+[а-яё]+)*)';
  const DEN = '(?:половин[а-я]*|втор(?:ая|ой|ую|ых|их)|трет(?:ья|ью|ей|и|их|ь(?:я|ью|ей|и|их)?)|четверт(?:ь|и|ую|ых|ой)|пят(?:ая|ую|ых|и)|шест(?:ая|ую|ых|и)|седьм(?:ая|ую|ых|и)|восьм(?:ая|ую|ых|и)|девят(?:ая|ую|ых|и)|десят(?:ая|ую|ых|и))';
  const re = new RegExp(`(^|\\s)${NUM}\\s+${DEN}(?=\\s|$|[.,!?;:])`, 'gi');
  return str.replace(re, (match, lead) => lead || ' ');
}

function stripRootsAndPowers(str){
  const TERM = '(?:[а-яё0-9.,]+(?:\\s+[а-яё0-9.,]+)*)';
  let s = String(str);
  const rootPattern = new RegExp(`(?:квадратн[а-я]*\\s+корень|кубическ[а-я]*\\s+корень|корень(?:\\s+[а-яё]+)*)\\s+из\\s+${TERM}`, 'gi');
  s = s.replace(rootPattern, ' ');
  const powerPattern = new RegExp(`${TERM}\\s+в\\s+(?:квадрате|кубе|степени\\s+${TERM})`, 'gi');
  s = s.replace(powerPattern, ' ');
  return s;
}


// Удаляем токены, не относящиеся к числам или операциям
function stripIrrelevantTokens(str){
  return str
    .split(/\s+/)
    .map(tok => tok.replace(/^[.,!?;:]+|[.,!?;:]+$/g,''))
    .map(tok => tok.replace(/[×xх]/g,'*').replace(/[÷:]/g,'/'))
    .filter(tok=>{
      if(!tok) return false;
      if(['+','-','*','/','(',')'].includes(tok)) return true;
      if(/^[-+]?\d+(?:[.,]\d+)?%$/.test(tok)) return true;
      if(/^процент(?:а|ов)?$/i.test(tok)) return true;
      const low = tok.toLowerCase();
      return /^[-+]?\d+(?:[.,]\d+)?$/.test(tok) ||
             UNITS[low] !== undefined || TENS[low] !== undefined || HUNS[low] !== undefined ||
             /^тысяч/.test(low) || /^миллион/.test(low) || /^миллиард/.test(low) ||
             low==='млн' || low==='млрд';
    })
    .join(' ');
}

function parseExpression(textRaw){
  let text = textRaw.toLowerCase().replace(/ё/g,'е').replace(/\s+/g,' ').trim();
  // Возможное перечисление масштабов через запятую/точку → складываем
  let t = text
    .replace(/((?:\d+|[ а-яёa-z]+(?:\s+[а-яёa-z]+)*)\s+(?:тысяч[а-я]*|тыс\.?|миллион[а-я]*|млн\.?|миллиард[а-я]*|млрд\.?))\s*[\.,]\s+(?=\S)/gi, '$1 плюс ')
    .replace(/(\S)\s*[\.,]\s+((?:\d+|[ а-яёa-z]+(?:\s+[а-яёa-z]+)*)\s+(?:тысяч[а-я]*|тыс\.?|миллион[а-я]*|млн\.?|миллиард[а-я]*|млрд\.?)\b)/gi, '$1 плюс $2')
    .replace(/руб(ль|ля|лей)/g,' ').replace(/коп(ейка|ейки|еек)/g,' ')
    .replace(/[−–—-]/g,'-')
    .replace(/(посчитай|посчитать|сколько будет|сколько|сосчитай|итого|в итоге|равно)/g,' ')
    .trim();

    // Базовая нормализация и явные операции
  t = normalizeNumeralTypos(t);
  t = t
    .replace(/(умнож[а-я]*?)\s+на/g,' * ')
    .replace(/(помнож[а-я]*?)\s+на/g,' * ')
    .replace(/(^|[^a-zа-яё0-9])(умнож[а-я]*|помнож[а-я]*)(?=($|[^a-zа-яё0-9]))/g,'$1 * ')
    .replace(/(раздели|разделить|подели|поделить|дели)\s+на/g,' / ')
    .replace(/(^|[^a-zа-яё0-9])(раздели|разделить|подели|поделить|дели)(?=($|[^a-zа-яё0-9]))/g,'$1 / ')
    .replace(/(^|[^a-zа-яё0-9])плюс(?=($|[^a-zа-яё0-9]))/gi,'$1 + ')
    .replace(/(^|[^a-zа-яё0-9])минус(?=($|[^a-zа-яё0-9]))/gi,'$1 - ')
    .replace(/(\d)\s*[×xх]\s*(\d)/g,'$1 * $2') // "2 х 3"
    .replace(/[÷:]/g,'/')
    .replace(/\s+/g,' ')
    .trim();

  // 1) «X на Y» даже без «умножь»
  t = fixNaMultiplication(t);
  t = fixNaDivision(t);
  // 2) "10% 5" → "10% * 5"
  t = insertStarAfterPercent(t);
  t = stripRootsAndPowers(t);
  t = stripFractionPhrases(t);
  // 3) Хвост после "*": множители через пробел/"и"/запятую
  t = expandMultiplicativeList(t);
  t = insertStarsAfterStar(t);
  t = insertStarsBetweenBareNumbers(t);
  t = collapseRepeatedStars(t);
  // 4) удаляем посторонние слова
  t = stripIrrelevantTokens(t);
  // 5) между цифрами может потеряться «плюс»: "1380 4" → "1380 + 4"
  t = insertPlusBetweenNumbers(t);
  // 6) схлопываем дублирующиеся операторы ("- -" → "-")
  t = t.replace(/([+\-*/])\s*\1+/g,'$1');

  const parts = t.split(/([+\-*/])/).filter(p=>p.trim()!=='');
  const out=[], disp=[];
  let pendingUnaryMinus=false;

  for(const part of parts){
    let s=part.trim();

    if(['+','-','*','/'].includes(s)){
      if (s==='-' && (out.length===0 || ['+','-','*','/','('].includes(out[out.length-1]))) {
        pendingUnaryMinus=true;
        continue;
      }
      out.push(s);
      const opDisplay = s==='*' ? '×' : s==='/' ? '÷' : s;
      disp.push(' ' + opDisplay + ' ');
      continue;
    }


    let m;
    if(m = s.match(/^(.+?)\s*(%|процент(?:а|ов)?)$/)){
      const n = extractNumberRu(m[1]);
      out.push('(' + n + '/100)');
      disp.push(formatNumberSpaces(n)+'%');
      pendingUnaryMinus=false;
      continue;
    }
    let n = extractNumberRu(s);
    if (pendingUnaryMinus){
      if (!n.startsWith('-')) n='-'+n;
      pendingUnaryMinus=false;
    }
    out.push(n);
    disp.push(formatNumberSpaces(n));
  }

  const sanitized = out.join('');
  const display = disp.join('').trim();
  if(!sanitized) throw new Error('Пустое выражение');
  if(!/^[0-9+\-*/.() ]+$/.test(sanitized)) throw new Error('Недопустимые символы');
  return {display, sanitized};
}

function prettyMathForDisplay(src){
  return String(src);
}

const calc = s=>{ const v = Function('\"use strict\";return('+s.replace(/--/g,'+')+')')(); if(!isFinite(v)||isNaN(v)) throw 0; return parseFloat(Number(v).toFixed(4)).toString(); };

    /* ===== UI helpers ===== */
    const UI={ status:$('#status'), expr:$('#expr'), full:$('#full'), btnTitle:$('#btnTitle'),
      setListening(on){ this.status.innerHTML = on? '<div class="dots"><span></span><span></span><span></span></div>' : ''; if(this.btnTitle) this.btnTitle.textContent = on? 'ГОВОРИ' : 'НАЖМИ'; },
      msg(m){ if(this.status) this.status.textContent=m; }
    };

    function fitFullText(text){
      const el = UI.full; if(!el) return;
      if (typeof text === 'string') el.textContent = text;
      if (!fitFullText._raf) fitFullText._raf = 0; cancelAnimationFrame(fitFullText._raf);
      fitFullText._raf = requestAnimationFrame(()=>{
        const parent = el.parentElement || el;
        const pad = 0.98; // небольшой внутренний отступ
        const MAX = 72, MIN = 18;

        // черновая оценка (по длине строки), чтобы меньше прыгало
        const len = el.textContent.length || 1;
        const rough = Math.min(MAX, Math.max(MIN, Math.floor((parent.clientWidth * pad) / Math.max(8, len))));
        el.style.fontSize = rough + 'px';

        // уточняем двоичным поиском — быстро и стабильно
        let low = MIN, high = MAX, best = rough;
        for (let i=0;i<12;i++){
          const mid = Math.round((low+high)/2);
          el.style.fontSize = mid + 'px';
          if (el.scrollWidth <= parent.clientWidth * pad){ best = mid; low = mid + 1; } else { high = mid - 1; }
        }
        el.style.fontSize = best + 'px';

        // при переполнении оставляем видимым правый край
        const overflow = el.scrollWidth > parent.clientWidth;
        el.dataset.overflow = overflow ? '1' : '0';
        el.style.textAlign = 'right';
      });
    }

    let lastPreview = { display:'', out:'' };
    function updateLive(phrase){
      if(!phrase) return; // ничего не считаем
      let parsed;
      try{
        parsed = parseExpression(phrase);
      }catch{
        lastPreview = { display:'', out:'' };
        if(UI.expr){ UI.expr.textContent=''; UI.expr.scrollLeft=0; }
        fitFullText('');
        return;
      }

      const {display,sanitized} = parsed;
      const pretty = prettyMathForDisplay(display);
      lastPreview = { display: pretty, out:'' };
      if(UI.expr){ UI.expr.textContent=pretty; UI.expr.scrollLeft=UI.expr.scrollWidth; }

      try{
        const out = calc(sanitized);
        const outFmt = formatNumberSpaces(out);
        lastPreview.out = outFmt;
        fitFullText(outFmt);
      }catch{
        fitFullText('');
      }
    }

    /* ===== Вспомогательная склейка сегментов без дублей ===== */
    function findSubsequenceIndex(haystackTokens, needleTokens){
      const h = haystackTokens.map(tok=>tok.toLowerCase());
      const n = needleTokens.map(tok=>tok.toLowerCase());
      if(!n.length || n.length>h.length) return n.length===0 ? 0 : -1;
      outer: for(let i=0;i<=h.length-n.length;i++){
        for(let j=0;j<n.length;j++){
          if(h[i+j]!==n[j]) continue outer;
        }
        return i;
      }
      return -1;
    }

    // Склеиваем группы тысяч вида "1 590" в "1590", чтобы новые сегменты
    // без пробелов не считались отличными и не дублировали число.
    function normalizeDigitGroups(str){
      return String(str).replace(/(^|[^\d])(\d{1,3}(?:\s\d{3})+)(?!\d)/g, (_,lead,num)=>lead+num.replace(/\s+/g,''));
    }

    function mergeSegmentsNoDup(arr){
      const normTok = tok => String(tok||'').toLowerCase().replace(/[.,!?;:]/g,'');
      const tokensEqual = (a,b)=>{
        if(a.length!==b.length) return false;
        for(let i=0;i<a.length;i++){
          if(normTok(a[i])!==normTok(b[i])) return false;
        }
        return true;
      };
      const isOperatorToken = tok => {
        const n = normTok(tok);
        return n==='+'||n==='-'||n==='*'||n==='/'||
               n==='плюс'||n==='минус'||n==='умножь'||n==='умножить'||
               n==='помножь'||n==='помножить'||n==='дели'||n==='раздели'||
               n==='разделить'||n==='подели'||n==='на';
      };
      let acc='';
      for(const raw of arr){
        let sRaw=String(raw||'').replace(/[−–—-]/g,'-').replace(/\s+/g,' ').trim();
        if(!sRaw) continue;
        let sTokensRaw = sRaw.split(' ').filter(Boolean);
        let s = normalizeDigitGroups(sRaw);
        if(acc) acc = normalizeDigitGroups(acc);
        if(!acc){ acc=s; continue; }

        const accTokens = acc.split(' ').filter(Boolean);

        if(accTokens.length && sTokensRaw.length){
          const occurrences=[];
          for(let i=0;i<=sTokensRaw.length-accTokens.length;i++){
            const rawChunk = sTokensRaw.slice(i, i+accTokens.length).join(' ');
            const chunkTokens = normalizeDigitGroups(rawChunk).split(' ').filter(Boolean);
            if(tokensEqual(chunkTokens, accTokens)) occurrences.push(i);
          }
          if(occurrences.length>1){
            let changed=false;
            for(let idx=occurrences.length-1; idx>=0; idx--){
              const pos=occurrences[idx];
              if(pos===occurrences[0]) continue;
              const prevTok=sTokensRaw[pos-1];
              if(prevTok && isOperatorToken(prevTok)) continue;
              sTokensRaw.splice(pos, accTokens.length);
              changed=true;
            }
            if(changed){
              sRaw = sTokensRaw.join(' ');
              s = normalizeDigitGroups(sRaw);
            }
          }
        }

        let sTokens = s.split(' ').filter(Boolean);

        if(accTokens.length>=2 && sTokens.length){
          const lastTokRaw = accTokens[accTokens.length-1] || '';
          const opNorm = lastTokRaw.toLowerCase().replace(/[^+\-*/а-яё]/g,'');
          if(opNorm==='-' || opNorm==='минус' || opNorm==='+' || opNorm==='плюс'){
            const isNumPart = tok => {
              const low = tok.toLowerCase().replace(/[.,!?;:]/g,'');
              if(!low) return false;
              if(low==='и') return true;
              if(/^\d+(?:[.,]\d+)?$/.test(low)) return true;
              if(UNITS[low]!==undefined || TENS[low]!==undefined || HUNS[low]!==undefined) return true;
              if(/^тысяч/.test(low) || /^миллион/.test(low) || /^миллиард/.test(low) || low==='млн' || low==='млрд') return true;
              return false;
            };
            let start = accTokens.length-2;
            while(start>=0 && isNumPart(accTokens[start])) start--;
            start++;
            const prevPhraseTokens = accTokens.slice(start, accTokens.length-1);
            const prevPhrase = prevPhraseTokens.join(' ');
            const prevVal = Number(extractNumberRu(prevPhrase));
            if(!isNaN(prevVal)){
              let dropLen = 0;
              for(let len=1; len<=sTokens.length; len++){
                const prefix = sTokens.slice(0,len).join(' ');
                const prefixVal = Number(extractNumberRu(prefix));
                if(!isNaN(prefixVal) && prefixVal===prevVal){
                  dropLen = len;
                  break;
                }
              }
              if(dropLen){
                sTokens = sTokens.slice(dropLen);
                s = sTokens.join(' ');
                if(!sTokens.length) continue;
              }
            }
          }
        }

        let merged=false;

        for(let k=Math.min(sTokens.length, accTokens.length); k>0; k--){
          const tailStr = accTokens.slice(-k).join(' ');
          const headStr = sTokens.slice(0,k).join(' ');
          const valTail = Number(extractNumberRu(tailStr));
          const valHead = Number(extractNumberRu(headStr));
          if(!isNaN(valTail) && !isNaN(valHead) && valTail===valHead){
            acc = accTokens.slice(0,-k).concat(sTokens).join(' ');
            merged=true;
            break;
          }
        }
        if(merged) continue;

        const idxContainedInAcc = findSubsequenceIndex(accTokens, sTokens);
        if(idxContainedInAcc !== -1){
          // Новый сегмент полностью содержится в уже накопленной строке —
          // игнорируем его, чтобы не дублировать числовую часть.
          continue;
        }

        const idxAccInsideNew = findSubsequenceIndex(sTokens, accTokens);
        if(idxAccInsideNew !== -1){
          // Новый сегмент включает предыдущий. Оставляем его целиком, но сначала
          // уберём подряд идущие повторы предыдущей фразы без операторов между ними,
          // иначе получим "300 + 5 300 + 5".
          const occurrences=[];
          for(let i=0;i<=sTokens.length-accTokens.length;i++){
            const chunk=sTokens.slice(i,i+accTokens.length);
            if(tokensEqual(chunk, accTokens)) occurrences.push(i);
          }
          if(occurrences.length>1){
            let changed=false;
            for(let idxIdx=occurrences.length-1; idxIdx>=0; idxIdx--){
              const pos=occurrences[idxIdx];
              if(pos===idxAccInsideNew) continue;
              const prevTok=sTokens[pos-1];
              if(prevTok && isOperatorToken(prevTok)) continue;
              sTokens.splice(pos, accTokens.length);
              changed=true;
            }
            if(changed){
              s=sTokens.join(' ');
            }
          }
          acc = s;
          continue;
        }

        const tail = accTokens.slice(-8).join(' ').trim();
        if (tail && s.startsWith(tail)) acc = acc + s.slice(tail.length);
        else if (!acc.endsWith(s)) acc = acc + ' ' + s;
      }
      return acc.trim();
    }

    /* ===== Распознавание (Web + Cordova) ===== */
    let sessionActive=false;
    const recognizer={ mode:'none', available:false,
      start(){ UI.msg('Распознавание речи недоступно. Нужен HTTPS/localhost или плагин Cordova.'); navigator.vibrate && navigator.vibrate(30); },
      stop(){},
      restartIfNeeded(){}
    };

    (function setupWeb(){
      const SR=window.SpeechRecognition||window.webkitSpeechRecognition; const secure = location.protocol==='https:' || location.hostname==='localhost' || location.hostname==='127.0.0.1';
      if(!SR || !secure) return;
      let rec=null; let silenceTimer=null; let buffer='';

      const looksIncomplete = (txt)=>/(\b(?:с|и)\s*половин)|\b[01]?\s*\/\s*2\b/i.test(txt);
      function clearSilence(){ if(silenceTimer){ clearTimeout(silenceTimer); silenceTimer=null; } }
        function armSilence(){ clearSilence(); silenceTimer=setTimeout(()=>{ try{ rec && rec.stop(); }catch{} }, 1500); }

        function configure(){
          rec = new SR();
          rec.lang='ru-RU';
          rec.interimResults=true;
          rec.maxAlternatives=16;
          rec.continuous = false;

        rec.onresult = (e)=>{
          const results = Array.from(e.results||[]);
          const segBest = results.map(seg => {
            const arr = Array.from(seg);
            const score = cand => {
              const s = String(cand.transcript||'');
              let val = cand.confidence;
              const frac = /(половин(?:а|ой|у|ы)?|втор(?:ых|ая|ой|ую)|трет(?:их|ья|ей|ью)|четверт(?:ых|ая|ой|ую)|пят(?:ых|ая|ой|ую)|шест(?:ых|ая|ой|ую)|седьм(?:ых|ая|ой|ую)|восьм(?:ых|ая|ой|ую)|девят(?:ых|ая|ой|ую)|десят(?:ых|ая|ой|ую))(?:\s|$)/i;
              if (frac.test(s)) val += 1;
              if (/тыс|млн|млрд|миллион|миллиард/i.test(s)) val += 0.5;
              return val + s.length/1000;
            };
            arr.sort((a,b)=> score(b)-score(a));
            return arr[0]?.transcript || '';
          });
          const joined = mergeSegmentsNoDup(segBest);
          if(joined){ buffer = joined; updateLive(buffer); }
          if(!looksIncomplete(joined)) armSilence(); else clearSilence();
        };
          rec.onerror = ()=>{ if(sessionActive){ stopSession(); } };
          rec.onend   = ()=>{ clearSilence(); if(!sessionActive) return; stopSession(); };
      }

        function startSession(){
          if(sessionActive) return;
          sessionActive=true;
          UI.setListening(true);
          fitFullText('');
          if(UI.expr){ UI.expr.textContent=''; UI.expr.scrollLeft=0; }
          lastPreview = { display:'', out:'' };
          buffer='';
          configure();
          try{ rec.start(); }catch{}
        }
      function stopSession(){ if(!sessionActive) return; sessionActive=false; clearSilence(); try{ rec && rec.stop(); }catch{} UI.setListening(false); if(lastPreview.display){ pushHistory(lastPreview.display,lastPreview.out); } }

      recognizer.mode='web'; recognizer.available=true;
      recognizer.start=startSession; recognizer.stop=stopSession; recognizer.restartIfNeeded=function(){ if(sessionActive){ try{ rec && rec.start(); }catch{} } };

      document.addEventListener('visibilitychange', ()=>{ if(document.hidden && sessionActive){ stopSession(); } });
    })();

    document.addEventListener('deviceready', ()=>{
      try{
        const rec = window.plugins && window.plugins.speechRecognition; if(!rec) return;
        recognizer.mode='cordova'; recognizer.available=true;

        let buffer=''; let silenceTimer=null; let lastChunk='';
        function clearSilence(){ if(silenceTimer){ clearTimeout(silenceTimer); silenceTimer=null; } }
          function armSilence(){ clearSilence(); silenceTimer=setTimeout(()=>{ stopSession(); }, 1500); }

        function loopStart(){
          if(!sessionActive) return;
          rec.startListening( matches=>{
            const chosen = (matches||[])[0] ? String(matches[0]) : '';
            if(chosen){
              const merged = mergeSegmentsNoDup([buffer, chosen]);
              buffer = merged; lastChunk = chosen;
              updateLive(buffer);
              if(/(с\s*половин|1\s*\/\s*2|½)/i.test(buffer)) clearSilence(); else armSilence();
            }
          }, ()=>{ if(sessionActive){ setTimeout(loopStart, 150); } }, { language:'ru-RU', matches:8, showPartial:true, showPopup:false });
        }

          function startSession(){
            if(sessionActive) return;
            sessionActive=true;
            UI.setListening(true);
            fitFullText('');
            if(UI.expr){ UI.expr.textContent=''; UI.expr.scrollLeft=0; }
            lastPreview = { display:'', out:'' };
            buffer='';
            lastChunk='';
          rec.hasPermission(has=>{ const go=()=>{ loopStart(); }; if(has) go(); else rec.requestPermission(go, ()=> UI.msg('Нет доступа к микрофону.')); }, ()=> UI.msg('Ошибка проверки разрешений.'));
        }
        function stopSession(){ clearSilence(); if(!sessionActive) return; sessionActive=false; try{ rec.stopListening(()=>{},()=>{}); }catch{} UI.setListening(false); if(lastPreview.display){ pushHistory(lastPreview.display,lastPreview.out); } }

        recognizer.start=startSession; recognizer.stop=stopSession;
      }catch{}
    }, false);

    $('#btnListen').addEventListener('click', e=>{ e.preventDefault(); if(!recognizer.available){ UI.msg('Нужен HTTPS/localhost (Web) или плагин speechrecognition (Cordova).'); navigator.vibrate && navigator.vibrate(30); return; } if(!sessionActive) recognizer.start(); else recognizer.stop(); });

    try{ const calcView=document.querySelector('#view-calc'); if(window.ResizeObserver&&calcView){ const ro=new ResizeObserver(()=>fitFullText()); ro.observe(calcView); } window.addEventListener('resize', ()=>fitFullText()); window.addEventListener('orientationchange', ()=>fitFullText()); }catch{}

    renderHistory();
  })();
  </script>
</body>
</html>
